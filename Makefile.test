###############################################################################
# Licensed Materials - Property of IBM Copyright IBM Corporation 2017. All Rights Reserved.
# U.S. Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP
# Schedule Contract with IBM Corp.
#
# Contributors:
#  IBM Corporation - initial API and implementation
###############################################################################

SHELL := /bin/bash
TOP := $(BUILD_DIR)

# GITHUB_USER containing '@' char must be escaped with '%40'
GITHUB_USER := $(shell echo $(GITHUB_USER) | sed 's/@/%40/g')
GITHUB_TOKEN ?=
ARTIFACTORY_TOKEN ?=


.PHONY: init\:
init::
ifndef GITHUB_USER
	$(info GITHUB_USER not defined)
	exit 1
endif
	$(info Using GITHUB_USER=$(GITHUB_USER))
ifndef GITHUB_TOKEN
	$(info GITHUB_TOKEN not defined)
	exit 1
endif

-include $(shell curl -so .build-harness -H "Authorization: token $(GITHUB_TOKEN)" -H "Accept: application/vnd.github.v3.raw" "https://raw.github.ibm.com/ICP-DevOps/build-harness/master/templates/Makefile.build-harness"; echo .build-harness)

.PHONY: keys\:
## Generate ssh key pair
keys:
	@$(SELF) -s ssh:keys
	@echo -e "\nContents of id_rsa:"
	@cat $(SSH_KEY_FILE)
	@echo -e "\nContents of id_rsa.pub:"
	@cat $(SSH_KEY_FILE).pub

.PHONY: keys\:clean
## Delete ssh key pair
keys\:clean:
	@$(shell rm -f id_rsa id_rsa.pub)

.PHONY: deploy-amd64-openstack\:
## Create amd64 build on HDC BlueRidgeGroup tenant
deploy-amd64-openstack: %deploy-amd64-openstack:
	@$(SELF) -s deploy:openstack OPENSTACK_DEPLOY_DIR=.deploy-amd64-openstack OPENSTACK_TERRAFORM_VARS_FILE=.deploy-amd64-openstack.tfvars
ifdef ARTIFACTORY_TOKEN
	$(info saving terraform state in artifactory)
	@$(SELF) -s terraform:save-state TERRAFORM_STATE_ARTIFACTORY_TOKEN=$(ARTIFACTORY_TOKEN) TERRAFORM_STATE_ARTIFACTORY_PATH=$(TRAVIS_REPO_SLUG)/$(TRAVIS_BUILD_NUMBER) TERRAFORM_DIR=.deploy-amd64-openstack TERRAFORM_VARS_FILE=.deploy-amd64-openstack.tfvars
endif

.PHONY: deploy-amd64-openstack\:config
## Configure kubectl for access to amd64-openstack build
deploy-amd64-openstack\:config:
	@$(SELF) -s kubectl:install
	@$(SELF) -s kubectl:config K8S_CLUSTER_NAME=$(shell $(SELF) terraform:output TERRAFORM_DIR=.deploy-amd64-openstack TERRAFORM_OUTPUT_VAR=cluster-name) K8S_CLUSTER_MASTER_IP=$(shell $(SELF) terraform:output TERRAFORM_DIR=.deploy-amd64-openstack TERRAFORM_OUTPUT_VAR=master-node)
	@$(SELF) -s helm:config K8S_CLUSTER_NAME=$(shell $(SELF) terraform:output TERRAFORM_DIR=.deploy-amd64-openstack TERRAFORM_OUTPUT_VAR=cluster-name) K8S_CLUSTER_MASTER_IP=$(shell $(SELF) terraform:output TERRAFORM_DIR=.deploy-amd64-openstack TERRAFORM_OUTPUT_VAR=master-node)
	@$(SELF) -s helm:init
	@echo INFO: You can now access your cluster with "kubectl config use-context $(shell $(SELF) terraform:output TERRAFORM_DIR=.deploy-amd64-openstack TERRAFORM_OUTPUT_VAR=cluster-name)"
	@echo INFO: You can access your cluster web console at $(shell $(SELF) terraform:output TERRAFORM_DIR=.deploy-amd64-openstack TERRAFORM_OUTPUT_VAR=web-console)

.PHONY: deploy-amd64-openstack\:clean\:
## Clean up amd64-openstack build artifacts
deploy-amd64-openstack\:clean:
	@$(SELF) -s deploy:openstack:clean OPENSTACK_DEPLOY_DIR=.deploy-amd64-openstack OPENSTACK_TERRAFORM_VARS_FILE=.deploy-amd64-openstack.tfvars
ifdef ARTIFACTORY_TOKEN
	$(info deleting terraform state in artifactory)
	@$(SELF) -s terraform:delete-state TERRAFORM_STATE_ARTIFACTORY_TOKEN=$(ARTIFACTORY_TOKEN) TERRAFORM_STATE_ARTIFACTORY_PATH=$(TRAVIS_REPO_SLUG)/$(TRAVIS_BUILD_NUMBER) TERRAFORM_DIR=.deploy-amd64-openstack
endif

.PHONY: deploy-power-openstack\:
## Create power build on HDC BlueRidgeGroup-P tenant
deploy-power-openstack: %deploy-power-openstack:
	@$(SELF) -s deploy:openstack OPENSTACK_DEPLOY_DIR=.deploy-power-openstack OPENSTACK_TERRAFORM_VARS_FILE=.deploy-power-openstack.tfvars
ifdef ARTIFACTORY_TOKEN
	$(info saving terraform state in artifactory)
	@$(SELF) -s terraform:save-state TERRAFORM_STATE_ARTIFACTORY_TOKEN=$(ARTIFACTORY_TOKEN) TERRAFORM_STATE_ARTIFACTORY_PATH=$(TRAVIS_REPO_SLUG)/$(TRAVIS_BUILD_NUMBER) TERRAFORM_DIR=.deploy-power-openstack TERRAFORM_VARS_FILE=.deploy-power-openstack.tfvars
endif

.PHONY: deploy-power-openstack\:config
## Configure kubectl for access to power-openstack build
deploy-power-openstack\:config:
	@$(SELF) -s kubectl:install
	@$(SELF) -s kubectl:config K8S_CLUSTER_NAME=$(shell $(SELF) terraform:output TERRAFORM_DIR=.deploy-power-openstack TERRAFORM_OUTPUT_VAR=cluster-name) K8S_CLUSTER_MASTER_IP=$(shell $(SELF) terraform:output TERRAFORM_DIR=.deploy-power-openstack TERRAFORM_OUTPUT_VAR=master-node)
	@$(SELF) -s helm:config K8S_CLUSTER_NAME=$(shell $(SELF) terraform:output TERRAFORM_DIR=.deploy-power-openstack TERRAFORM_OUTPUT_VAR=cluster-name) K8S_CLUSTER_MASTER_IP=$(shell $(SELF) terraform:output TERRAFORM_DIR=.deploy-power-openstack TERRAFORM_OUTPUT_VAR=master-node)
	@$(SELF) -s helm:init
	@echo INFO: You can now access your cluster with "kubectl config use-context $(shell $(SELF) terraform:output TERRAFORM_DIR=.deploy-power-openstack TERRAFORM_OUTPUT_VAR=cluster-name)"
	@echo INFO: You can access your cluster web console at $(shell $(SELF) terraform:output TERRAFORM_DIR=.deploy-power-openstack TERRAFORM_OUTPUT_VAR=web-console)

.PHONY: deploy-power-openstack\:clean
## Clean up power-openstack build artifacts
deploy-power-openstack\:clean:
	@$(SELF) -s deploy:openstack:clean OPENSTACK_DEPLOY_DIR=.deploy-power-openstack OPENSTACK_TERRAFORM_VARS_FILE=.deploy-power-openstack.tfvars
ifdef ARTIFACTORY_TOKEN
	$(info deleting terraform state in artifactory)
	@$(SELF) -s terraform:delete-state TERRAFORM_STATE_ARTIFACTORY_TOKEN=$(ARTIFACTORY_TOKEN) TERRAFORM_STATE_ARTIFACTORY_PATH=$(TRAVIS_REPO_SLUG)/$(TRAVIS_BUILD_NUMBER) TERRAFORM_DIR=.deploy-power-openstack
endif

.PHONY: deploy-amd64-vsphere\:
## Create amd64-vsphere build on https://ibmpcvc65.rtp.raleigh.ibm.com/
deploy-amd64-vsphere: %deploy-amd64-vsphere:
	@$(SELF) -s deploy:vsphere VSPHERE_DEPLOY_DIR=.deploy-amd64-vsphere VSPHERE_TERRAFORM_VARS_FILE=.deploy-amd64-vsphere.tfvars
ifdef ARTIFACTORY_TOKEN
	$(info saving terraform state in artifactory)
	@$(SELF) -s terraform:save-state TERRAFORM_STATE_ARTIFACTORY_TOKEN=$(ARTIFACTORY_TOKEN) TERRAFORM_STATE_ARTIFACTORY_PATH=$(TRAVIS_REPO_SLUG)/$(TRAVIS_BUILD_NUMBER) TERRAFORM_DIR=.deploy-vsphere-openstack TERRAFORM_VARS_FILE=.deploy-vsphere-openstack.tfvars
endif

.PHONY: deploy-amd64-vsphere\:config
## Configure kubectl for access to amd64-vsphere build
deploy-amd64-vsphere\:config:
	@$(SELF) -s kubectl:install
	@$(SELF) -s kubectl:config K8S_CLUSTER_NAME=$(shell $(SELF) terraform:output TERRAFORM_DIR=.deploy-amd64-vsphere TERRAFORM_OUTPUT_VAR=cluster-name) K8S_CLUSTER_MASTER_IP=$(shell $(SELF) terraform:output TERRAFORM_DIR=.deploy-amd64-vsphere TERRAFORM_OUTPUT_VAR=master-node)
	@$(SELF) -s helm:config K8S_CLUSTER_NAME=$(shell $(SELF) terraform:output TERRAFORM_DIR=.deploy-amd64-vsphere TERRAFORM_OUTPUT_VAR=cluster-name) K8S_CLUSTER_MASTER_IP=$(shell $(SELF) terraform:output TERRAFORM_DIR=.deploy-amd64-vsphere TERRAFORM_OUTPUT_VAR=master-node)
	@$(SELF) -s helm:init
	@echo INFO: You can now access your personal cluster with "kubectl config use-context $(shell $(SELF) terraform:output TERRAFORM_DIR=.deploy-amd64-vsphere TERRAFORM_OUTPUT_VAR=cluster-name)"
	@echo INFO: You can access your cluster web console at $(shell $(SELF) terraform:output TERRAFORM_DIR=.deploy-amd64-vsphere TERRAFORM_OUTPUT_VAR=web-console)

.PHONY: deploy-amd64-vsphere\:clean\:
## Clean up amd64-vsphere build artifacts
deploy-amd64-vsphere\:clean:
	@$(SELF) -s deploy:vsphere:clean VSPHERE_DEPLOY_DIR=.deploy-amd64-vsphere VSPHERE_TERRAFORM_VARS_FILE=.deploy-amd64-vsphere.tfvars
ifdef ARTIFACTORY_TOKEN
	$(info deleting terraform state in artifactory)
	@$(SELF) -s terraform:delete-state TERRAFORM_STATE_ARTIFACTORY_TOKEN=$(ARTIFACTORY_TOKEN) TERRAFORM_STATE_ARTIFACTORY_PATH=$(TRAVIS_REPO_SLUG)/$(TRAVIS_BUILD_NUMBER) TERRAFORM_DIR=.deploy-vsphere-openstack
endif

.PHONY: setup-dependencies
setup-dependencies:
	@$(SELF) -s log:init
	sudo ln -s $(PWD)/build-harness/vendor/terraform /usr/local/bin/terraform
	sudo ln -s $(PWD)/build-harness/vendor/kubectl /usr/local/bin/kubectl
	if [ ! -d "test-output" ]; then \
		mkdir -p test-output/daily; \
	fi
	git clone https://token:$(GITHUB_TOKEN)@github.ibm.com/IBMPrivateCloud/icp-infrastructure-bats.git
	git clone https://github.com/hchenxa/bats.git
	cd bats; sudo ./install.sh /usr/local
	\cp -ar tests/* icp-infrastructure-bats/suites/management-ingress

.PHONY: run-daily-tests
run-daily-tests:
	$(call assert-set,TARGET)
	@echo "INFO: run tests here... kubectl will already be configured if using deploy-* targets from above"
	@$(SELF) -s kubectl:cmd KUBECTL_COMMAND=cluster-info
	@echo -e "INFO: Cluster Pod Status:"
	@$(SELF) -s kubectl:cmd KUBECTL_COMMAND="get pods -o wide -n kube-system"
	@echo -e "INFO: Helm List Releases:"
	@$(SELF) -s helm:tls-cmd HELM_COMMAND=ls K8S_CLUSTER_NAME=$(shell $(SELF) terraform:output TERRAFORM_DIR=.$(TARGET) TERRAFORM_OUTPUT_VAR=cluster-name)
	cd icp-infrastructure-bats; \
	$(SHELL) run.sh -g management-ingress | tee ../test-output/daily/daily-tests.tap
	@$(SELF) log:test LOG_TEST_OUTPUT_DIR=test-output/daily

.PHONY: run-all-tests
run-all-tests:
	$(call assert-set,TARGET)
	@echo "INFO: run tests here... kubectl will already be configured if using deploy-* targets from above"
	@$(SELF) -s kubectl:cmd KUBECTL_COMMAND=cluster-info
	@echo -e "INFO: Cluster Pod Status:"
	@$(SELF) -s kubectl:cmd KUBECTL_COMMAND="get pods -o wide -n kube-system"
	@echo -e "INFO: Helm List Releases:"
	@$(SELF) -s helm:tls-cmd HELM_COMMAND=ls K8S_CLUSTER_NAME=$(shell $(SELF) terraform:output TERRAFORM_DIR=.$(TARGET) TERRAFORM_OUTPUT_VAR=cluster-name)
	#@$(SELF) log:test LOG_TEST_OUTPUT_DIR=#path to test tap output file

.PHONY: pause
pause:
	sleep 240
